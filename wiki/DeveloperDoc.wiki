#summary Documentation for plug-in developers.
#labels Featured

<wiki:toc max_depth="2" />

= Folder Structure =

To be able to develop plug-ins for ManiaLive you need to understand how files are arranged.
Open the ManiaLive folder and take a look at what you find inside:<br>
*config* : contains the configuration file(s).<br>
*data* : holds files/sqlite databases for threading.<br>
*libraries* : contains all code (core and plug-ins) of ManiaLive.<br>
*logs* : self-explanatory, by default contains all log-files that are generated.<br>
In the next step we take a closer look onto the libraries folder. It contains the “ManiaLive” and the “ManiaHome” package. At last you can also find a folder in there called “ManiaLivePlugins”, that of course is where you will begin writing.

= The Libraries-Folder Structure =

  # Class names are case sensitive and every word in the name starts with a capital letter.
  # Namespaces are folders in the file-system.
  # Classes have to be in files that have the same name and end with .php<br>class Example will be in the file Example.php

= The ManiaLivePlugins-Folder Structure =

The “ManiaLivePlugins” folder will contain only sub-folders named after plug-in authors. Each of them contains sub-folders named after the plug-ins itself and in each of those folders you will find at least a php file that is named like the folder it is contained by, so for instance:
ManiaLivePlugins/Bob/Dedimania/Dedimania.php
Will be the main file for the plug-in named “Dedimania” and who's author is “Bob”.
It is a good habit to always use the same author name. One way to avoid collisions with other plug-in authors is to use the unique Trackmania login.
In ManiaLive sometimes there is used a plug-in-id. This consists of the author name of the plug-in, a backslash and the name of the plug-in (eg. Bob\Dedimania).
Within the folder of a plug-in you can create your own file structure (you are restricted to use some conventions listed below).

= Conventions for Creating Plug-ins =

  # Every Plug-in needs to be located in the “ManiaLivePlugins" folder.	
  # In “ManiaLivePlugins” there has to be a folder named after the plug-in's author.
  # A plug-in is situated in a folder named after the plug-in's author. As for author name it is recommended to use the TM login to avoid naming collisions with other authors.	
  # A Plug-in consists of a folder with the name of the plug-in.
  # In the folder, that is named like the plug-in, there has to be a file which is named after the plug-in with “.php” extension.
  # This file needs to have a definition for a class that also has the name of the plug-in.
  # The class, which has got the plug-in's name, has to be inherited from the ManiaLive\Plug-inHandler\Plugin class.

= Loading a Plug-in =

You can load a plug-in that has been created using the conventions above by simply adding a line into your “config.ini”:<br>
plug-ins.load[] = *Bob\Dedimania*<br>
The bold text has to be replaced by the ID of your plug-in, which is described in “The Plug-in's Folder Structure”.
To see what configuration is loaded check the Loader_pid.txt log in your logs folder.

= The Plug-in Class =

*\ManiaLive\PluginHandler\Plugin* is the base class for all plug-ins and provides the interface for all events that can occur.
There are many helper methods that are built into the Plug-in class for beginners to keep ways short. If you are an experienced programmer, you can figure out how to use the different components that are wrapped into the helpers yourself.
When you create your plug-in, you can specify how the loader will be treating it during the load process.

== Set Plug-in Version ==

It is a good habit to increase a plug-in’s version number with every release and change of its features. This way all depending plug-ins know if they might not be supporting the current version anymore.
Setting a version number is done by using the *setVersion(float $number)* method.

== Add Dependencies ==

If your plug-in is using functionalities of a currently existing one, you can easily add a dependency to this.
All dependencies are obligatory, so if a plug-in, that has been added to the dependency-list is not loaded - due to whatever - also every depending plug-in will fail to load.
To add a dependency, use the following sample:

{{{
$dependency = new Dependency('Author\Plugin', 1, 2);
$this->addDependency($dependency);
}}}

= Events =

If you have created the plug-in file regarding the “Conventions for Creating Plug-ins” and added a line to the config.ini to load it, it won't be doing anything yet.
One of the core components of ManiaLive is the event dispatching system.
All of the plug-in's interaction is triggered by some event taking place in the core components.<br>
When a plug-in is loaded it is being hooked to the so called Dispatcher.
To react on events you simply need to define a method in your class with the corresponding name, that will be called every time this event occurs.<br>
*Every plug-in will only be notified of the event types that it is enabled for.*<br>
On start-up the only events that will be received are the “Plug-in Events”, any other category needs to be enabled.<br>
In the following the different event types and its corresponding event methods are described.

== Plug-in Events ==

=== onInit() ===
Called before the plug-in is actually loaded and registered for any events. After onInit is executed the loading process can still fail. This is why *onInit* should only be used to define plug-in specific properties that are important for the loading process. This can for instance be the version number or dependencies.

=== onLoad() ===
Your plug-in has been accepted, but not all plug-ins have been loaded yet.
So if you want to interact with some other plug-in, this is still the wrong place.

=== onReady() ===
Plug-in loading is completely finished. If you now want to access interfaces of other plug-ins, this is the right place to do it.

== Application Events ==

Disabled by default.
Enable them in the plug-in's *onLoad* or *onReady* event:
$this->enableApplicationEvents();

=== onRun() ===
Is triggered directly after *onReady*, the only difference is that you need to enable the application events.

=== onPreLoop() ===
The ManiaLive application is one big loop of instructions which is repeated up to 50 times per second. *onPreLoop* is executed on begin of every round, putting any code here can drastically decrease the performance of your application, so be aware!

=== onPostLoop() ===
Is executed on every loop's round end.
See *onPreLoop* for more details.

=== onTerminate() ===
Executed when application is terminating in the usual way.

== Dedicated Server Events ==

Disabled by default.
Enable them in the plug-in's *onLoad* or *onReady* event:
{{{
$this->enableDedicatedEvents();
}}}
You can find a detailed explanation of the dedicated server's events in the “ListCallbacks.html” in the same folder as the “TrackmaniaServer.exe“ can be found.
To get the corresponding method for a callback, you just prefix the callback's name with an “on”. The callback “PlayerConnect” for instance becomes *onPlayerConnect*.
Parameters remain unchanged.

== Windowing Events ==

Disabled by default.
Enable them in the plug-in's *onLoad* or *onReady* event:
{{{
$this->enableWindowingEvents();
}}}

=== onWindowClose($login, $window) ===

A window has been closed on some player's screen.

== Threading Events ==

Disabled by default.
Enable them in the plug-in's *onLoad* or *onReady* event:
{{{
$this->enableThreadingEvents();
}}}

=== onThreadStart($thread) ===
A Thread has been started successfully.

=== onThreadDies($thread) ===
A thread that is not busy did not respond to a ping within a given time window.
It will be restarted.

=== onThreadTimesOut($thread) ===
Thread has been working for too long and is not responding.
Will be killed and restarted.

=== onThreadRestart($thread) ===
A thread that has either died or timed out is restarted.

== Storage Events ==

Disabled by default.
Enable this in the plug-in's *onLoad* or *onReady* event:
{{{
$this->enableStorageEvents();
}}}

=== onPlayerNewBestScore($player, $score_old, $score_new) ===
Player got a new best score on the current track.

=== onPlayerNewBestTime($player, $best_old, $best_new) ===
Player drove a new best time on the current track.

=== onPlayerNewRank($player, $rank_old, $rank_new) ===
Player climbed up or moved down in the rankings table of the current track.

== Ticker Event ==

Disabled by default.
Enable this in the plug-in's *onLoad* or *onReady* event:
{{{
$this->enableTickerEvent();
}}}

=== onTick() ===
Occurs every second.

= Console and Logging =

For the purpose of displaying text on the screen, there is the *writeConsole(string $text)* helper method that is inherited with the Plugin class. To log text into a plug-in specific log file, use the *writeLog(string $text)*.
Never use the print or echo functions directly, because if necessary the intern Console class is going to write into the log file. For more freedom, you can also use the *\ManiaLive\Utilities\Console* and *\ManiaLive\Utilities\Logger* classes directly.

= Plug-in Interaction =

To interact between Plug-ins, you can use the intern method *setPublicMethod(string $method)* to expose a method from the plug-in to other loaded plug-ins. Plug-ins normally don't have access to each other, except you explicitly set a method to public.
Once that is done, you can use *callPublicMethod(string $plugin_id, string $method, mixed $arg1, mixed $arg2 …)* to call a method from another plug-in, that has been set public before – of course.
To check whether the plug-in exists, you can call *isPluginLoaded(string $plugin_id)* before, instead of adding the plug-in to the dependencies list.
You should avoid adding dependencies as much as possible.

= Storage Usage =

The storage class, is used to avoid you to send request to the server to get datas. This class contain the following properties:

  * *players* : which is an array containing *\ManiaLive\DedicatedApi\Structures\Player* detailed information. Those players are the people playing the current track and not those in spectator mod.
  * *spectators* : this is an array containing *\ManiaLive\DedicatedApi\Structures\Player* detailed information.<br>Those players are the people connected as spectator on the server.
  * *ranking* : is an sorted array containing the current ranking.<br>Each value is of type *\ManiaLive\DedicatedApi\Structures\Player*
  * *challenges* : is an array of *\ManiaLive\DedicatedApi\Structures\Challenge*.<br>Those challenges are the current tracks set on the server.
  * *currentChallenge*: is a *\ManiaLive\DedicatedApi\Structures\Challenge* representing the current track 
  * *nextChallenge*: is a *\ManiaLive\DedicatedApi\Structures\Challenge* representing the next track, except if a restart challenge is done.
  * *server*: is a *\ManiaLive\DedicatedApi\Structures\ServerOptions* which represents sur value in Config file of the dedicated server
  * *gameInfos*: is a *\ManiaLive\DedicatedApi\Structures\GameInfos* which contains every information about the current game.
  * *serverStatus*: is a *\ManiaLive\DedicatedApi\Structures\Status*. It indicate whether the server is stopped, or running
  * *serverLogin*: is a string containing the login of the dedicated server.

Each property is update when an event is fired by the dedicated server. This class is the first called by the ManiaLive core when it received a callback, so it’s data are allways up to date. If a data is stored in the storage system you shouldn’t need to call the server to get it. This class should be used as a read only system, do not try to edit or insert some data in any property.

= Chat Commands =

You want to have interaction between the people on your dedicated server and ManiaLive, then using chat commands will be the first and simplest step!
The Plugin class once again offers an easy wrapper function to have callbacks executed when a specific command is entered in the game.
*\ManiaLive\Features\ChatCommand\Command registerChatCommand(string $command_name, string $callback_method, integer $parameter_count = 0, boolean $add_login = false, array $authorizedLogin = array())*
This might be almost self explanatory. First parameter takes the chat command, without the “/”, that needs to be entered in game. Second parameter is the name of the method that is executed. parameter_count defines how many parameters are expected after the command, separated by spaces. These will be set as parameters for the callback. If add login is set to true, then your callback additionally needs to have the login of the player as first parameter. authorizedLogin is an array of the players that are allowed to use your command. It is suggested to use the admin list that is managed in your config.ini. You can access it by using the *\ManiaLive\Features\Admin\AdminGroup* and call its static method *contains(string $login)* to check whether the player that has tried to use the chat command is registered to the admin group.

= Databases =

Using a database connection with ManiaLive is pretty easy.
There are two types of databases that are supported by the core:
  * MySQL
  * SQLite

Both connections support the same interface and can be used in the same way.
If you want to create a connection, then it is recommended to use the static *\ManiaLive\Database\Connection \ManiaLive\Database\Connection::getConnection(string $host, string $username, string $password, string $database, string $type, int $port)*
Should you require the same connection twice the currently established connection will be used instead of creating a new. If several plug-ins are using the same database, they ergo will share the connection.

= Windowing System =

Now that you know the basics of ManiaLive, the last thing you need to know is how to make your progress accessible to the big crowds on your server.
The dedicated server allows us by passing it xml manialinks to draw an interface for specific players.
ManiaLive brings this to a new level, you don’t have to know all details of formatting manialink pages and rendering them to xml. There are just three components that are used to draw elements onto the screen:
  * *Elements* are the smallest units that can be drawn.<br>If you want to compare them with anything, then they are just like files on your disk.
  * *Controls* consist of several elements or once again controls itself.<br>They can be used to group *components* (which is the umbrella term for either elements or controls) and combine them with logic, this way they can result in a versatile and reusable object, that you will be able to share between all your projects.<br>Put into comparison, this would be folders in your hard drive.
  * *Windows* can contain components and additionally can be drawn onto the screen. They also offer helpers for positioning.

== Creating a Window ==

You start by creating a PHP-file that is named just like the window. Usually this file is located in the plug-in folder and within a ”Gui” and further more a “Windows” folder.
The “Gui” folder is the super folder for all graphical components and thus contains the “Windows” folder, which is predestined for all Windows components.
Editing this file you will create a class inside that has once again the name of the window (pay attention to case sensitive naming).
Specified class will need to be inherited from *\ManiaLive\Gui\Windowing\Window*, the base class for all windows.
For windows there are four methods that can be overwritten, to define the behaviour and look of the window depending on what is happening:

=== initializeComponents() ===
This will be executed only once the window is being created the first time, you don’t need to draw it on the screen. It will be performed just the first time you are mentioning this window anywhere in your code. So this is the place where you should, as the name implies, create the components that you want to have on your window.
Components are added to a Window in two steps (this also applies for adding to a Control), first you instanciate the class, then you use the Window’s
*addComponent(ManiaLive\Gui\Toolkit\Drawable $component)*-method to assign this component.
Depending on whether the size of the Window is static or may be changed during the runtime you will position its components either in *initializeComponents* or *onShow*.

=== onShow() ===
Is called every time the *show()* method of the window is being called, thus on every refresh.
If you want to scale and reposition your components, then do this here.

=== onHide() ===
Called when the window is being removed from the screen.
If you want to disable certain events while the window is not on the screen.

=== onRecover() ===
Executed whenever the window has been hidden and is recovered back to the displayed state.

== Important Namespaces and its Classes ==

For each of the existing component types there are already predefined namespaces that contain a set of helpful objects that were created during the use of ManiaLive until now.

=== \ManiaLive\Gui\Toolkit\Elements ===

For a further description of these elements, see the ManiaLib documentation.
The process of instantiating and using them should be almost the same, except you don’t call the save method, but the addComponent method of the component that you want to draw it on.
  * *Audio*
  * *BgRaceScore2*
  * *Bgs1*
  * *Bgs1InRace*
  * *BgsChallengeMedals*
  * *BgsPlayerCard*
  * *Button*
  * *Element*
  * *Entry*
  * *FileEntry*
  * *Format*
  * *Icons128x128_1*
  * *Icons128x32_1*
  * *Icons64x64_1*
  * *IncludeManialink*
  * *Label*
  * *MedalsBig*
  * *Music*
  * *Quad*
  * *Spacer*
  * *Video*

=== \ManiaLive\Gui\Windowing\Controls ===

  * *ButtonResizeable*<br>Same as the normal Button element, but you can change its size.
  * *Frame*<br>Add controls to a frame, position them and define size.<br>Apply a layout if you want.
  * *PageNavigator*<br>Helps you building a navigation for a multiple paged window.
  * *Panel*<br>Standard window background, you can even have a close button.
  * *Tab*<br>Inherit this with another control and add an instance to 
  * *Tabview*<br>Add controls of instance Panel, you will be able to choose one of them that will be displayed.

=== \ManiaLive\Gui\Windowing\Windows ===

  * Dialog<br>Create a simple window with predefined buttons.<br>Enable the window events for the plug-in and if dialog window is closed, get the answer property from the dialog.
  * Info<br>Just display a simple window with message inside and title.

= Threading =

Last but not least, there is something called threading in ManiaLive.
Most of you probably know what that is when speaking of normal software applications.
ManiaLive is different, since PHP does not support threading, there had to be a different way to do time consuming stuff (slow database queries, remote procedures, blocking connections) without having a frozen main application.
Another thing is security, a crashing thread can be restarted and the main loop will rest unaffected.
Although the idea of multi-threading somehow sounds more exciting than the good old PHP style it is recommended to use it as rarely as possible!
Due to the fact, that this is not an inbuilt functionality and relies on many other libraries/functions and also depends on what kind of system you are using, it is on its way of becoming a bit unstable again. For this reason there is a compatibility mode that can execute the work that has been assigned to threads in a sequential way. That way, if your plug-in does make use of the threading feature, but it has been deactivated, manialive will still be able to load and use it. All the work that normally would be assigned to another process will then be executed in the main loop and thus there might be some performance loss.

== Creating a Thread ==

The Plugin class contains a helper method that will create a thread:
{{{
createThread()
}}}
This will only create one Thread per plug-in, even if you call it more than once.
This documentation will only explain how to manage threads with the plug-in intern helper functions. If you want to discover the full potential of the threading library, you will need to look up the source code files or the more detailed phpUml documentation.

== Create Work ==

Okay, so you have some stuff that you do want to be executed on the thread, but how do you need to prepare the data for the thread to be able to work with it?
There is a class *\ManiaLive\Threading\Runnable* that you need to extend. This extended class now has a method *run()* that you will be able to overwrite. You can also add properties to the class to be able to store data or instructions. The run-method is what is exectued on the other process. Now that you have created your Runnable-class you need to instantiate it and if needed set properties.

== Assign Work to a Thread ==

You should have an object now that is a subtype of *\ManiaLive\Threading\Runnable*, to assign it to a thread there are two possibilities. (These methods are inherited with the Plugin class)
First you can assign the work to any thread that currently is free or least busy. If there are several threads created by plug-ins you won’t know where your work will be processed.
{{{
sendWorkToThread(\ManiaLive\Threading\Runnable $work)
}}}
Using method number two, you will always assign work to the thread created by your plug-in. This might come in handy if, for instance, if you need a resistant connection (see Dedimania).
sendWorkToOwnThread(ManiaLive\Threading\Runnable $work)